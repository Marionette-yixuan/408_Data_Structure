<font face="Source Code Pro"/>

[toc]

## 绪论

### 基本概念

- **数据**是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。
- **数据元素**是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。
- 一个数据元素可由若干个**数据项**组成。数据项是数据不可分割的最小单位。
- **数据对象**是性质相同的数据元素的集合，是数据的一个子集。

> 图书馆里的所有书的书目信息可以看作一个数据；
> 某一本书的书目信息就是一个数据元素；
> 这本书的书名、作者名、出版时间等就是一个数据项。

#### 数据结构

**数据结构**是相互之间存在一种或多种特定关系的数据元素的集合。数据元素之间的关系称为**结构**。
> **数据对象**不强调元素之间的关系，**结构**强调的是元素之间的关系。

##### 四类基本结构

- **集合**：元素之间除同属一个集合外无其他关系。
- **线性结构**：元素之间存在**一对一**的关系。即除第一个元素外，每个元素都有唯一前驱；除最后一个元素外，每个元素都有唯一后继。
- **树形结构**：元素之间存在**一对多**的关系。
- **图状结构**（无向）或**网状结构**（有向）：元素之间存在**多对多**的关系。

数据结构的三要素：**逻辑结构**、**物理结构**、**运算方法**。

- **逻辑结构**：[结构](#数据结构)定义中的“关系”描述的是数据元素之间的逻辑关系，所以又叫**逻辑结构**。
- **物理结构**：数据结构在计算机中的表示（又称映像）称为数据的**物理结构**，又称**存储结构**。
  > 存储结构会影响：1. 存储空间分配的方便程度&nbsp;&nbsp;2. 数据的运算速度
  - **顺序存储**：逻辑上相邻的元素在物理上也相邻。元素间关系用存储单元的**邻接关系**来体现。
  - **链式存储**：逻辑上相邻，物理上不一定相邻。由**指针**来表示元素间的关系。
  - **索引存储**：建立附加的索引表来保存数据的**关键字**和**存储地址**。
  - **散列存储**：根据元素的关键字**计算出**存储地址，又叫哈希存储。

#### 数据类型

**数据类型**是一个**值的集合**和定义在这个值集上的**一组操作**的总称，包括非结构的**原子类型**（如整型、字符型、指针类型、空类型等）和**结构类型**。

##### 抽象数据类型

**抽象数据类型**是指一个数学模型以及定义在该模型上的一组操作。 抽象数据类型的定义仅取决于它的一组**逻辑特性**，而与其在计算机内部如何表示和实现无关。

---

### 算法和算法分析

**算法**是对特定问题求解步骤的一般描述，它是指令的有限序列，其中每一条指令表示一个或多个操作。 算法具有以下5个重要特性：

1. **有穷性**：一个算法总是在执行**有穷步**后结束，且每一步可在**有穷时间**内完成。
   > 算法必须是有穷的，程序可以是无穷的
2. **确定性**：对于相同的输入只能得出相同的输出。
3. **可行性**：算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现的。
4. **输入**：一个算法有**零个或多个**输入。
5. **输出**：一个算法有**一个或多个**输出。

#### 算法复杂度

算法中基本操作重复执行的次数是问题规模 $n$ 的某个函数 $f(n)$，算法的时间量度记作 $T(n)=O(f(n))$，表示随问题规模 $n$ 的增大，算法执行时间的增长率和 $f(n)$ 的增长率相同，$T(n)$ 称作算法的**
渐进时间复杂度**，简称**时间复杂度**。

**算法复杂度排序**：$O(1)\lt O(\log{n})\lt O(n)\lt O(n\log{n})\lt O(n^2)\lt O(n^3)\lt O(2^n)\lt O(n!)\lt O(n^n)$
**加法规则**：$O(f(n))+O(g(n))=O(\max\{f(n), g(n)\})$
**乘法规则**：${O(f(n))}\times{O(g(n)})=O({f(n)}\times{g(n)})$
> 计算算法复杂度时，只保留次数最大项的一倍结果即可，且一般只考虑**平均**或**最差**时间复杂度。

---
---

## 线性表

**线性表**是具有**相同数据类型**的 $n$ 个数据元素的**有限**序列，其中 $n$ 为表长，当 $n=0$ 时线性表是一个**空表**。 若将线性表记为 $(a_1, \dotsc, a_{i-1}, a_i, a_{i+1},
\dotsc, a_n)$，则称 $a_{i-1}$ 是 $a_i$ 的直接**前驱**元素，$a_{i+1}$ 是 $a_i$ 的直接**后继**元素，$i$ 为元素 $a_i$ 在线性表中的**位序**。
> **下标**是从0开始的，**位序**是从1开始的。

---

### 顺序表

线性表的顺序表示是指用一组**地址连续**的存储单元依次存储线性表的数据元素，即逻辑上相邻的元素物理存储上也相邻。
代码见[SqList.c](https://github.com/Marionette-yixuan/408_Data_Structure/blob/4c89d55ff33ef09fb5020dc81f9d692865706787/List/SqList/SqList.c)。

``` c
/* 线性表 */
#define LIST_INIT_SIZE 100      // 线性表存储空间的初始分配量
#define LISTINCREMENT 10        // 存储空间的分配增量

typedef struct {
  ElemType *elem;               // 存储空间的基址
  int length;                   // 当前线性表的长度
  int listsize;                 // 当前分配的存储容量（当前表的最大容量）
} SqList;
```

顺序表的特点：

- **随机访问**，即可以在 $O(1)$ 时间内找到第 $i$ 个元素。
- **存储密度高**，每个结点只存储数据元素。
- **拓展容量不方便**，必须要重新分配地址空间，然后迁移数据。
- **插入、删除操作不方便**，需要移动大量元素。

#### 顺序表的插入和删除

##### 插入操作 `ListInsert_Sq(SqList *L, int i, ElemType e)`

插入操作基本流程：

1. 判定插入位置i是否合法：i的合法范围为**1~L.length+1**。
2. 判定当前表是否已满。若已满，则需要增加表长、重新分配存储空间，然后迁移数据。
3. 获取插入位置的元素：L.elem[i-1]。
4. **从后往前**依次将插入位置（**含**）之后的元素**后移**。
5. 将新元素e插入表中。
6. 增加表长 L.length++。

时间复杂度：

- 最好情况：插入到**表尾**，不需移动元素，时间复杂度为 $O(1)$。
- 最坏情况：插入到**表头**，需要移动所有元素，时间复杂度为 $O(n)$。
- 平均情况：插入到各个位置的概率相同，时间复杂度为 $O(\frac{n}{2})=O(n)$。

##### 删除操作 `ListDelete_Sq(SqList *L, int i, ElemType *e)`

删除操作基本流程：

1. 判断删除位置i是否合法：i的合法范围为**1~L.length**。
2. 获得删除位置的元素：L.elem[i-1]。
3. **从前往后**依次将删除位置（**不含**）之后的元素**前移**。
4. 减少表长 L.length--。

时间复杂度：

- 最好情况：删除表尾元素，不需移动元素，时间复杂度为 $O(1)$。
- 最坏情况：删除表头元素，所有元素都需要前移，时间复杂度为 $O(n)$。
- 平均情况：插入到各个位置的概率相同，时间复杂度为 $O(\frac{n-1}{2})=O(n)$。

即在顺序存储结构的线性表中插入或删除一个数据元素，平均约移动表中**一半**的元素。

---

### 链表

线性表的链式存储结构是用一组**任意的**存储单元存储线性表的数据元素（可连续也可不连续）。 因此除了存储本身的数据信息外，还需要存储其直接后继的存放位置。这两部分信息共同构成一个**结点**，结点中存储数据信息的域叫做**数据域**
，存储直接后继信息的域叫做**指针域**。

链表的特点：

- 不要求大量**连续的**存储空间，改变容量方便。
- 不可随机存取，必须从首结点一路向下找到目标结点。
- 需要耗费一定空间用作指针域。
- 插入、删除元素操作简单。

#### 单链表

单链表是指指针域只有**一个**指向后继元素的指针的链表。
代码见[LkList.c](https://github.com/Marionette-yixuan/408_Data_Structure/blob/4c89d55ff33ef09fb5020dc81f9d692865706787/List/LkList/LkList.c)。

``` c
/* 单链表 */
typedef struct LNode {
  ElemType data;            // 数据域
  struct LNode *next;       // 指针域
} LNode, *LinkList;        // LNode强调结点本身，LinkList强调整个链表的指针
```

##### 实现方式

单链表有两种实现方式：带头结点&不带头结点。**头结点**是指一个数据域为空（也可以存储如表长之类的数据）、指针域指向整个链表第一个结点（**首结点**）的结点。两种实现方法的差异主要在**初始化**和**判空**的操作上。

- 不带头结点：不带头结点时，指向单链表的指针L（**头指针**）直接指向**首结点**。
  **初始化**方法：`L = NULL`，代表表中没有结点；
  **判空**方法：`L == NULL`，即头指针为空则说明表空。 不带头结点时，在链表头部插入和删除元素时都需要更改头指针，不太方便。

- 带头结点：带头结点时，头指针L指向**头结点**。
  **初始化**方法：申请一片空间给头结点`head_node`，随后头指针`L`指向头结点、头结点的指针域置NULL。
  **判空**方法：`L.next == NULL`。L指向的是头结点，头结点没有后继元素代表链表为空。

判断结点p是否为表尾的操作（两种实现方法相同）：`p.next == NULL`
由于带头结点的单链表显然更加常用，所以以下操作均为带头结点的实现方法。

##### 插入操作 `ListInsert_Lk(LinkList L, int i, ElemType e)`

假设要插入的元素e存放在名为**s**的结点指针中，表中插入位置i的**上一个结点**的指针为**p**（即s结点插入到p的后侧），则关键步骤如下：

1. `s->next = p->next`，p原本的后继元素变为s的后继元素。
2. `p->next = s`，p的新后继元素为s。
   <img src="z_pics/linklist_insert.jpeg" width="60%"/>

两步的顺序十分重要，不能颠倒！

时间复杂度：$O(n)$

> 指定结点**p**的**前插**操作：
> 方法一：从头结点找到p的前驱结点，进行插入。时间复杂度：$O(n)$
> 方法二：新建一个结点s插入到p后方，然后把p的数据内容复制到s中，随后用新元素e替换p中元素。时间复杂度：$O(1)$
> | s->next = p->next;
> | p->next = s;
> | s->data = p->data;
> | p->data = e;

##### 删除操作 `ListDelete_Lk(LinkList L, int i, ElemType *e)`

假设要删除结点（第i个结点）的**上一个结点**的指针为**p**（即删除p的下一个结点，设为**q**），则关键步骤如下：

1. `p->next = q->next`，p的新后继元素为要删除结点(q = p->next)的后继元素。
2. `free(q)`，释放q的存储空间，交还操作系统。
   <img src="z_pics/linklist_delete.jpeg" width="60%"/>

时间复杂度：$O(n)$

> 指定结点**p**的删除操作：
> 令**q**指向**p**的后一个结点，将q的数据域和指针域复制到p中，随后删除q结点。
> | q = p->next;
> | p->data = q->data;
> | p->next = q->next;
> | free(q);
> 除最后一个结点外都可以这样进行删除。时间复杂度：$O(1)$

单链表的局限性：**无法逆向检索**，要找到某个结点的前驱必须要从头结点进行遍历，花$O(n)$的时间复杂度。

#### 双链表

为了解决单链表无法逆向搜索的弊端，在指针域添加一个指向**前驱元素**的指针。牺牲少量存储密度换来更快捷的操作。
代码见[DuList.c](https://github.com/Marionette-yixuan/408_Data_Structure/blob/b7b40eaecb6fea49799191603d2131747b1fd70d/List/DuList/DuList.c)。

``` c
/* 双链表 */
typedef struct DNode {
  ElemType data;
  struct DNode *prior;    // 前驱指针域
  struct DNode *next;     // 后继指针域
} DNode, *DoubleList;
```

##### 初始化&判空（默认带头结点）

初始化时，申请一片内存空间用来存放头结点`head_node`，并将`head_node`的**前驱**和**后继指针域**置为NULL，随后双链表指针指向头结点。在后续操作中，头结点的前驱指针域**始终为NULL**。
，后继指针域指向首结点。 判空操作与单链表相同，`L->next == NULL`，即根据头结点的后继指针是否为NULL来判定。

##### 插入操作 `ListInsert_Du(DoubleList D, int i, ElemType e)`

假设要插入的元素e存放在名为**s**的结点指针中，表中插入位置i的**上一个结点**的指针为**p**（即s结点插入到p的后侧），则关键步骤如下：

1. `s->next = p->next`，同单链表。
2. `p->next->prior = s`，将原表中p的后继结点的前驱域（原本指向p）指向s。
3. `s->prior = p`，p为s的前驱。
4. `p->next = s`，同单链表。
   <img src="z_pics/doublelist_insert.jpeg" width="40%"/>

其中，2/3步的位置可以互换，其余两步位置固定。 第2步中，若插入在最后一个结点后方，可能会出现空指针的错误，所以要先判断`p->next == NULL`，即p有无后继结点。
对于前插操作，只需要找到i位置结点的前一个结点，再进行后插操作即可。

##### 删除操作 `ListDelete_Du(DoubleList D, int i, ElemType *e)`

假设要删除结点（第i个结点）的**上一个结点**的指针为**p**（即删除p的下一个结点，设为**q**），则关键步骤如下：

1. `p->next = q->next`，同单链表。
2. `q->next->prior = p`，p为原本q的后继结点的前驱。
3. `free(q)`，释放空间。
   <img src="z_pics/doublelist_delete.jpeg" width="40%"/>

同样，第2步可能会出现空指针的错误，需要进行判断。

#### 循环链表

循环链表分为循环单链表和循环双链表，其最大的特征是尾结点的后继指针不为NULL。

##### 循环单链表

循环单链表中，**尾结点的后继指针域回指向头结点**，而普通单链表的尾结点后继指针域则为NULL。
> 循环链表可以从任意一个结点出发，向后遍历找到任意一个结点。

代码见[CrList.c](https://github.com/Marionette-yixuan/408_Data_Structure/blob/80dbb854256203134a2307fb771bf9a23519117d/List/CrList/CrList.c)
<img src="z_pics/circlelist.jpeg" width="60%"/>

###### 初始化&判空&判表尾

- **初始化**：头结点`head_node`的指针域应指向头结点本身，即`head_node->next = head_node`。其余与单链表相同。
- **判空**：循环链表`C`为空的条件为`C->next == C`，即头结点的指针域指向自己。
- **判表尾**：结点`p`为循环链表`C`的表尾元素的条件为`p->next == C`，即指针域指向头结点。

###### 尾指针

由于对链表的很多操作都是在表头或者表尾进行，而从**头指针找到尾部**需要$O(n)$的时间复杂度，所以在循环链表中，可以不设头指针而改用**尾指针**，由**尾指针找到头部**只需要$O(1)$的时间复杂度，大大简化。当然，需要在**
表尾**插入和删除元素时需要修改尾指针的值。

##### 循环双链表

循环双链表在循环单链表的基础上，**尾结点的后继指针域指向头结点、头结点的前驱指针域指向尾结点**，与之相对的双链表的上述两个指针域均为NULL。 这部分没有代码。
<img src="z_pics/circledoublelist.jpeg" width="60%"/>

###### 初始化&判空&判表尾

- **初始化**：头结点`head_node`的前驱指针域和后继指针域均指向自己。
- **判空**：循环链表`C`为空的条件为`C->next == C`或`C->prior == C`，即头结点的两个指针域均指向自己。
- **判表尾**：结点`p`为循环链表`C`的表尾元素的条件为`p->next == C`，即指针域指向头结点。

##### 循环链表的插入和删除

在双链表的插入和删除操作（见[双链表](#插入操作-listinsert_dudoublelist-d-int-i-elemtype-e)
）中，需要判定操作位置是否为表尾，否则会出现空指针异常。而在循环链表中由于表尾元素的后继指针域不为NULL，所以无需进行判定，直接进行操作即可。

#### 静态链表

分配一整片连续的内存空间，每个内存单元中存放一个链表的结点，如下图。
<img src="z_pics/staticlist.jpeg" width="20%"/>

- 优点：增删操作不需要移动大量元素
- 缺点：不能随机存取，查找需要从头遍历元素。容量**固定不可变**。

适用场景：不支持指针的低级语言；数据元素数量固定不变的场景（如OS的文件分配表FAT）。 这部分没有代码。

``` c
/* 静态链表 */
#define MaxSize 10  // 静态链表的最大长度
typedef struct {
  ElemType data;    // 静态链表结构类型的定义
  int next;         // 下一个元素的数组下标
} SLinkList[MaxSize];   // SLinkList直接就是数组类型
```

##### 基本操作的实现方法

- **查找**：从头结点出发遍历后序结点（$O(n)$）
- **插入**第i个位置：
    1. 在表的内存空间中找到一个空（需预先设置**空结点**的特征，如`next = -2`）的结点`s`，存入数据
    2. 查找第i-1个结点`p`
    3. `s->next = p->next`
    4. `p->next = s`
- **删除**i位置的结点：
    1. 查找第i-1个结点`p`和第i个结点`q`
    2. `p->next = q->next`
    3. `q->next = -2`，表示这个结点为空了

---

### 栈

栈是限定仅在**表尾**进行插入或删除操作的**线性表**，栈的表尾被称作**栈顶**、表头端称为**栈底**。栈的特点就是**后进先出**（**LIFO**），后压入栈的元素会先出栈。

栈最重要的两个操作:

- **压栈**（**Push**）：将一个元素放置在栈顶。
- **弹栈**（**Pop**）：将栈顶元素取出。

#### 合法出栈序列

若有$n$个元素依次进栈，则有 $\frac{1}{n+1}\mathrm{C}^n_{2n}$ 种合法的出栈序列。 其中，若元素以 $\cdots{A}\cdots{B}\cdots{C}\cdots$ 的顺序入栈，则**不可能**出现
$\cdots{C}\cdots{A}\cdots{B}\cdots$ 的出栈序列。

#### 顺序栈

**顺序栈**就是利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设**top指针**指示栈顶元素在顺序栈中的位置。
代码见[SqStack.c](https://github.com/Marionette-yixuan/408_Data_Structure/blob/60da0b8eccf94b4c216f3267cb0d16a21454227a/Stack/SqStack/SqStack.c)。

``` c
/* 顺序栈 */
typedef struct {
  ElemType *base;       // 栈存储空间的基址，指向栈底的位置
  ElemType *top;        // 当前栈顶的地址
  int stack_size;       // 该顺序栈的最大容量
} SqStack;
```

- `base == NULL`说明栈**不存在**。
- `base == top`说明栈中无元素，为**空栈**。
- `top - base >= stack_size`说明栈**已满**。

> 教材上初始时`base == top`，每压入一个元素`top++`，这样会使top始终指向栈顶元素的**下一个位置**。
> 有些题目中会使top指针指向栈顶元素**本身**（王道网课的第一种方式top指针就是指向栈顶本身），记得读题。

##### 压栈操作 `Push(SqStack *S, ElemType e)`

关键步骤：

1. `S->base[top] = e`，将新元素放置在栈顶位置。
2. `S->top++`，栈顶指针增加。

> 如果是使用的第二种实现方法（top直接指向栈顶元素），则需要调换两步的位置，先增加top指针再入栈。

除此之外还要先进行栈满的判断，若已满则要重新分配更大的存储空间。

##### 弹栈操作 `Pop(SqStack *S, ElemType *e)`

关键步骤：

1. `S->top--`，先减少栈顶指针，使其指向栈顶元素。
2. `*e = S->base[top]`，元素出栈。

> 同样如果是使用的第二种实现方法，则先元素出栈再减少栈顶指针。

除此之外还要先进行栈空的判断，若为空则返回错误信息。

##### 共享栈

**共享栈**是顺序栈的一种变体，为两个栈共享同一片连续的内存空间， 栈底分别是内存空间的上下限，两个栈分别向中间生长。 这部分没有代码。

``` c
/* 共享栈：教材上没有这部分的介绍，所以使用了王道书上的定义风格 */
typedef struct {
  ElemType data[MaxSize];     // 静态数组代表连续内存空间
  int top0;                   // 0号栈栈顶指针
  int top1;                   // 1号栈栈顶指针
} ShStack;
```

**初始化**：`top0 = -1`，代表0号栈的栈顶元素在data[-1]（即没有元素）；`top1 = MaxSize`，代表1号栈的栈顶元素在data[MaxSize]（即没有元素）。
> **-1**和**MaxSize**都超出了数组的下标范围，可见这里使用的是第二种实现方式，即top指针直接指向栈顶元素。

**栈满**：`top1 - top0 == 1`，说明top1和top0相邻了，即两个栈生长到同一个位置了。

#### 链栈

**链栈**就是用单链表实现的栈结构，其定义与[单链表](#单链表)相同。其中，头结点的一端用作栈顶，方便操作。 对于两种不同实现方式，对应的基本操作也略有不同。

- 不带头结点： 只在**头指针处**进行插入、删除，对应压栈、弹栈操作。
- 带头结点： 只在**头结点后**进行插入、删除，对应压栈、弹栈操作。

代码见[LkStack.c](https://github.com/Marionette-yixuan/408_Data_Structure/blob/60da0b8eccf94b4c216f3267cb0d16a21454227a/Stack/LkStack/LkStack.c)。

#### 栈的应用

这一部分包括括号匹配、中缀表达式转后缀表达式以及后缀表达式求值。
其中括号匹配比较简单，就不给出文字描述了，代码在[LkStackMain.c](https://github.com/Marionette-yixuan/408_Data_Structure/blob/60da0b8eccf94b4c216f3267cb0d16a21454227a/Stack/LkStack/LkStackMain.c)中的`test3_19()`函数中。
另外两个应用的手算方法同样没有技术含量，下面只整理了计算机的处理方法。

##### 中缀表达式转后缀表达式

> 后缀表达式又称**逆波兰表达式**。

转换过程：

1. 初始化一个栈，来保存**不能确定运算顺序**的运算符（能确定的已经加到表达式里了）。
2. 从左到右处理中缀表达式：
    1. 遇到**操作数**：直接加入后缀表达式。
    2. 遇到**界限符**（即 **'('** 和 **')'**）： 遇到'('则直接入栈， 遇到')'则依次弹出栈内所有运算符并加入后缀表达式，直到遇到'('为止，然后将'('弹出但**不加入**表达式。
    3. 遇到**运算符**： 依次弹出栈内所有优先级**高于或等于**当前运算符的所有运算符，并加入后缀表达式。碰到'('或者栈空时停止， 之后将当前运算符入栈。
3. 读入结束后，将栈中剩余符号依次加入后缀表达式。

实例见[InToPost.pdf]()
